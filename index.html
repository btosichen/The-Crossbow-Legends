<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Crossbow Legends: Twilight Trials</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            /* Ë™øÊï¥ÁÇ∫Ëóç„ÄÅÁ∂†„ÄÅÁ¥ÖÁöÑÊ¥ªÊΩëÊº∏Â±§ */
            background: linear-gradient(180deg, #2196F3 0%, #4CAF50 55%, #FF5722 100%);
            font-family: 'Cinzel', 'Noto Sans TC', serif;
            color: #fff;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-sizing: border-box;
            transition: width 0.1s, height 0.1s;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #ffeb3b;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
        .zoomed #crosshair {
            width: 80px;
            height: 80px;
            border-color: #ffeb3b;
            border-width: 1px;
        }

        /* HUD */
        .hud-panel {
            padding: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        #top-bar {
            display: flex;
            justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
        }

        .score-box { font-size: 24px; color: #ffeb3b; }
        .timer-box { font-size: 32px; font-weight: bold; color: #ff5252; }
        .combo-box { 
            font-size: 40px; 
            font-weight: bold; 
            color: #00e5ff; 
            opacity: 0; 
            transition: opacity 0.2s;
            text-shadow: 0 0 15px #00e5ff;
        }
        .combo-active { opacity: 1; transform: scale(1.2); }

        #bottom-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
        }

        .ammo-display {
            font-size: 18px;
            text-align: right;
        }
        .ammo-type {
            font-size: 14px;
            color: #ddd;
        }
        .ammo-selected {
            color: #ffeb3b;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 5px #ffeb3b;
        }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 30, 40, 0.85); 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 5px;
            background: -webkit-linear-gradient(#fff, #ffeb3b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px; 
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        h2 { 
            font-size: 24px;
            color: #b0bec5; 
            margin-bottom: 40px; 
            letter-spacing: 2px;
            font-weight: 400;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffeb3b;
            color: #ffeb3b;
            padding: 12px 36px;
            font-size: 18px;
            font-family: 'Cinzel', serif;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 235, 59, 0.2), transparent);
            transition: 0.5s;
        }

        button:hover {
            background: rgba(255, 235, 59, 0.15);
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.4);
            color: #fff;
            transform: translateY(-2px);
        }
        button:hover::before { left: 100%; }

        .hidden { display: none !important; }

        /* Floating Text */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 0 5px black;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        #controls-hint {
            /* ÁßªÈô§ position: absoluteÔºåÊîπÁÇ∫Áî±Áà∂Â±§ Flexbox ÊéßÂà∂‰ΩçÁΩÆ */
            font-size: 14px;
            color: #ccc;
            text-align: left;
            line-height: 1.5;
        }
        .key {
            border: 1px solid #888;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-family: monospace;
            font-size: 12px;
        }

        #flash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
        }
        
        .hit-marker {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid #ff1744;
            transform: translate(-50%, -50%) rotate(45deg);
            opacity: 0;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

<div id="game-container"></div>
<div id="flash"></div>

<!-- Main Menu -->
<div id="main-menu" class="menu-overlay">
    <h1>The Crossbow Legends</h1>
    <h2>Twilight Trials</h2>
    <button onclick="Game.startMode('target')">üèπ Ê®°Âºè‰∏ÄÔºöÁ≤æÊ∫ñÂ∞ÑÈù∂</button>
    <button onclick="Game.startMode('defense')">üõ°Ô∏è Ê®°Âºè‰∫åÔºöÊùëËéäÈò≤Á¶¶</button>
    <button onclick="Game.startMode('patrol')">üå≤ Ê®°Âºè‰∏âÔºöËçíÂéüÂ∑°ÈÇè</button>
    
    <div style="margin-top: 40px; display: grid; grid-template-columns: 1fr 1fr; gap: 30px; text-align: left; border-top: 1px solid #555; padding-top: 20px;">
        <div>
            <p><span class="key">LMB</span> Â∞ÑÊìä</p>
            <p><span class="key">Shift</span> Á≤æÊ∫ñÁûÑÊ∫ñ (Èï∑Êåâ)</p>
            <p><span class="key">F</span> ÂàáÊèõÁÆ≠Áü¢</p>
        </div>
        <div>
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> ÁßªÂãï</p>
            <p><span class="key">R</span> Ë£ùÂ°´ | <span class="key">Space</span> Ë∑≥Ë∫ç</p>
            <p><span class="key">Q</span><span class="key">E</span> ÈñÉÈÅø</p>
        </div>
    </div>
</div>

<!-- Game Over / Pass Screen -->
<div id="game-over-screen" class="menu-overlay hidden">
    <h1 id="result-title">MISSION COMPLETE</h1>
    <h2 id="final-score">Score: 0</h2>
    <h3 id="multi-pass-msg" style="color: #ff5252; display: none; margin-bottom: 20px; font-size: 24px;">PASS THE CROSSBOW!</h3>
    <button onclick="Game.returnToMenu()">ËøîÂõû‰∏ªÈÅ∏ÂñÆ</button>
</div>

<!-- HUD -->
<div id="ui-layer" class="hidden">
    <div id="top-bar" class="hud-panel">
        <div class="score-box">SCORE: <span id="score-val">0</span></div>
        <div id="combo-display" class="combo-box">x0 COMBO</div>
        <div class="timer-box" id="timer-val">00:00</div>
    </div>
    
    <div class="hit-marker" id="hit-marker"></div>
    <div id="crosshair"></div>

    <div id="bottom-bar" class="hud-panel">
        <div id="controls-hint">
            <span class="key">WASD</span> Move | <span class="key">R</span> Reload | <span class="key">F</span> Switch Ammo
        </div>
        <div class="ammo-display">
            <div id="arrow-normal" class="ammo-type ammo-selected">‚û§ ÊôÆÈÄöÁÆ≠ (Normal)</div>
            <div id="arrow-rapid" class="ammo-type">‚ûµ ÈÄüÂ∞ÑÁÆ≠ (Rapid)</div>
            <div id="arrow-blast" class="ammo-type">üí£ ÁàÜË£ÇÁÆ≠ (Blast)</div>
            <div style="margin-top: 5px;">AMMO: <span id="ammo-count">60</span></div>
        </div>
    </div>
</div>

<script>
/**
 * ËÅ≤Èü≥ÂêàÊàêÂô® (Web Audio API)
 * ÁÑ°ÈúÄÂ§ñÈÉ®Ê™îÊ°àÔºåÁõ¥Êé•ÁîüÊàêÈü≥Êïà
 */
const AudioSynth = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    
    playTone: function(freq, type, duration, vol = 0.1) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    playShoot: function() {
        this.playTone(600, 'sawtooth', 0.1, 0.2);
        this.playTone(100, 'square', 0.15, 0.3); // Thud
    },
    
    playClick: function() {
        // Á©∫ÊßçËÅ≤
        this.playTone(800, 'square', 0.05, 0.1);
    },
    
    playReload: function() {
        this.playTone(300, 'triangle', 0.1, 0.1);
        setTimeout(() => this.playTone(400, 'triangle', 0.1, 0.1), 150);
    },

    playHitWood: function() {
        this.playTone(200, 'square', 0.1, 0.2);
    },

    playHitBullseye: function() {
        this.playTone(880, 'sine', 0.3, 0.3); // High pitch ding
        this.playTone(1760, 'sine', 0.3, 0.1);
    },

    playExplosion: function() {
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },

    playCombo: function(count) {
        const baseFreq = 440;
        this.playTone(baseFreq + (count * 50), 'triangle', 0.2, 0.2);
    }
};

/**
 * ÈÅäÊà≤‰∏ªÈÇèËºØ
 */
const Game = {
    scene: null, camera: null, renderer: null,
    mode: null,
    isPlaying: false,
    clock: new THREE.Clock(),
    entities: [],
    arrows: [],
    targets: [],
    particles: [],
    
    // Player State
    player: {
        mesh: null,
        speed: 10,
        canJump: false,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        isZoomed: false,
        ammoIndex: 0,
        lastShot: 0,
        reloading: false,
        ammoTypes: ['normal', 'rapid', 'blast'],
        // ÂΩàËó•Êï∏ÈáèÈôêÂà∂ÔºöÊôÆÈÄö=60, ÈÄüÂ∞Ñ=30, ÁàÜË£Ç=10
        ammoCounts: { 'normal': 60, 'rapid': 30, 'blast': 10 }, 
        score: 0,
        combo: 0,
        comboTimer: 0
    },

    // Environment
    raycaster: new THREE.Raycaster(),
    
    // Multi-pass
    currentPlayerIndex: 1,
    maxPlayers: 2,

    init: function() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0xd6eaf8, 0.012); 
        this.scene.background = null;

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(this.renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        this.scene.add(dirLight);
        
        window.addEventListener('resize', () => this.onWindowResize(), false);
        document.addEventListener('click', () => {
            if(this.isPlaying && !document.pointerLockElement) {
                document.body.requestPointerLock();
            }
        });
        
        this.bindInput();
        this.createWeapon();
        this.animate();
    },

    createWeapon: function() {
        const weaponGroup = new THREE.Group();
        const stockGeo = new THREE.BoxGeometry(0.15, 0.15, 0.6);
        const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
        const stock = new THREE.Mesh(stockGeo, woodMat);
        stock.position.set(0, -0.2, -0.4);
        weaponGroup.add(stock);

        const bowGeo = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
        const limb = new THREE.Mesh(bowGeo, metalMat);
        limb.rotation.z = Math.PI / 2;
        limb.position.set(0, -0.2, -0.6);
        weaponGroup.add(limb);

        this.camera.add(weaponGroup);
        this.player.weapon = weaponGroup;
        this.scene.add(this.camera);
    },

    bindInput: function() {
        this.keys = {};
        document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (e.code === 'KeyR') this.reload();
            if (e.code === 'Space') this.jump();
            if (e.code === 'KeyF') this.cycleAmmo(); // MMB -> F
            if (e.code === 'ShiftLeft') this.setZoom(true); // RMB -> Shift (Press)
            
            if ((e.code === 'KeyQ' || e.code === 'KeyE') && this.isPlaying) {
                this.dodge(e.code === 'KeyQ' ? -1 : 1);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
            if (e.code === 'ShiftLeft') this.setZoom(false); // RMB -> Shift (Release)
        });

        document.addEventListener('mousedown', (e) => {
            if (!this.isPlaying) return;
            if (e.button === 0) this.fireArrow();
            // Removed MMB and RMB click handlers
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body && this.isPlaying) {
                const sensitivity = this.player.isZoomed ? 0.001 : 0.002;
                this.camera.rotation.y -= e.movementX * sensitivity;
                const pitch = this.camera.rotation.x - e.movementY * sensitivity;
                this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                
                this.player.weapon.rotation.y = THREE.MathUtils.lerp(this.player.weapon.rotation.y, -e.movementX * 0.005, 0.1);
                this.player.weapon.rotation.x = THREE.MathUtils.lerp(this.player.weapon.rotation.x, -e.movementY * 0.005, 0.1);
            }
        });
    },

    startMode: function(modeName) {
        this.mode = modeName;
        this.isPlaying = true;
        this.resetGame();
        
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        
        document.body.requestPointerLock();
        
        this.buildLevel(modeName);
        this.startTimer(modeName === 'patrol' ? 120 : 60);
    },

    resetGame: function() {
        this.entities.forEach(e => this.scene.remove(e.mesh));
        this.targets.forEach(t => this.scene.remove(t.mesh));
        this.arrows.forEach(a => this.scene.remove(a.mesh));
        this.entities = [];
        this.targets = [];
        this.arrows = [];
        
        this.player.score = 0;
        this.player.combo = 0;
        
        // ÈáçÁΩÆÂΩàËó•
        this.player.ammoCounts = { 'normal': 60, 'rapid': 30, 'blast': 10 };
        this.updateUI();

        this.camera.position.set(0, 1.7, 5);
        this.camera.rotation.set(0, 0, 0);
    },

    buildLevel: function(mode) {
        const planeGeo = new THREE.PlaneGeometry(100, 100);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 1 }); 
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);
        this.entities.push({ mesh: ground, type: 'ground' });

        if (mode === 'target') {
            this.spawnTrees(20, 20);
            this.spawnRuins();
            this.levelLogic = this.updateTargetMode;
        } else if (mode === 'defense') {
            const centerGeo = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const centerMesh = new THREE.Mesh(centerGeo, new THREE.MeshStandardMaterial({color: 0x8d6e63}));
            this.scene.add(centerMesh);
            this.spawnTrees(40, 30);
            this.camera.position.set(0, 1.7, 0);
            this.levelLogic = this.updateDefenseMode;
        } else if (mode === 'patrol') {
            this.spawnTrees(15, 40);
            this.spawnRuins();
            this.levelLogic = this.updatePatrolMode;
        }
    },

    spawnTrees: function(count, radius) {
        for(let i=0; i<count; i++) {
            const h = 5 + Math.random() * 5;
            const treeGeo = new THREE.ConeGeometry(1, h, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x1b5e20 });
            const tree = new THREE.Mesh(treeGeo, treeMat);
            
            const angle = Math.random() * Math.PI * 2;
            const r = 10 + Math.random() * radius;
            tree.position.set(Math.cos(angle)*r, h/2, Math.sin(angle)*r);
            this.scene.add(tree);
            this.entities.push({ mesh: tree, type: 'wall' });
        }
    },

    spawnRuins: function() {
        for(let i=0; i<5; i++) {
            const geo = new THREE.BoxGeometry(2, 4, 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0x78909c });
            const ruin = new THREE.Mesh(geo, mat);
            ruin.position.set(Math.random()*40 - 20, 2, Math.random()*40 - 20);
            this.scene.add(ruin);
            this.entities.push({ mesh: ruin, type: 'wall' });
        }
    },

    // --- Actions ---

    cycleAmmo: function() {
        this.player.ammoIndex = (this.player.ammoIndex + 1) % this.player.ammoTypes.length;
        const types = ['arrow-normal', 'arrow-rapid', 'arrow-blast'];
        types.forEach(id => document.getElementById(id).classList.remove('ammo-selected'));
        document.getElementById(types[this.player.ammoIndex]).classList.add('ammo-selected');
        this.updateUI(); // Êõ¥Êñ∞ UI È°ØÁ§∫Êï∏Èáè
    },

    setZoom: function(zoom) {
        this.player.isZoomed = zoom;
        const targetFOV = zoom ? 40 : 75;
        new TWEEN.Tween(this.camera)
            .to({ fov: targetFOV }, 200)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(() => this.camera.updateProjectionMatrix())
            .start();
        
        if(zoom) document.body.classList.add('zoomed');
        else document.body.classList.remove('zoomed');
    },

    fireArrow: function() {
        const now = performance.now();
        const type = this.player.ammoTypes[this.player.ammoIndex];
        const cooldown = type === 'rapid' ? 150 : 600;

        if (now - this.player.lastShot < cooldown) return;
        
        // Ê™¢Êü•ÂΩàËó•ÊòØÂê¶Ë∂≥Â§†
        if (this.player.ammoCounts[type] <= 0) {
            AudioSynth.playClick(); // Á©∫ÂΩàÈü≥Êïà
            return;
        }

        this.player.lastShot = now;
        this.player.ammoCounts[type]--; // Êâ£Èô§ÂΩàËó•
        this.updateUI(); // Êõ¥Êñ∞È°ØÁ§∫

        AudioSynth.playShoot();

        const geo = new THREE.CylinderGeometry(0.02, 0.02, 0.8);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffee });
        const arrowMesh = new THREE.Mesh(geo, mat);
        
        arrowMesh.position.copy(this.camera.position);
        arrowMesh.position.add(new THREE.Vector3(0.2, -0.2, 0).applyQuaternion(this.camera.quaternion));
        
        arrowMesh.quaternion.copy(this.camera.quaternion);
        arrowMesh.rotateX(-Math.PI/2);

        const speed = type === 'rapid' ? 60 : 40;
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
        
        if (this.mode === 'defense') {
            dir.x += (Math.random() - 0.5) * 0.01;
            dir.y += (Math.random() - 0.5) * 0.01;
        }

        const arrow = {
            mesh: arrowMesh,
            velocity: dir.multiplyScalar(speed),
            gravity: type === 'rapid' ? 5 : 9.8,
            type: type,
            life: 3.0
        };

        this.scene.add(arrowMesh);
        this.arrows.push(arrow);
    },

    dodge: function(dir) {
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);
        right.y = 0; right.normalize();
        this.camera.position.add(right.multiplyScalar(dir * 2));
    },

    jump: function() {
        // ÁèæÂú®ÊâÄÊúâÊ®°ÂºèÈÉΩÂèØ‰ª•Ë∑≥Ë∫ç
        if (this.player.canJump) {
            this.player.velocity.y = 10;
            this.player.canJump = false;
        }
    },

    reload: function() {
        AudioSynth.playReload();
        
        // Â¶ÇÊûúÊòØÊôÆÈÄöÁÆ≠Áü¢‰∏îÊï∏ÈáèÈÅé‰ΩéÔºåÁµ¶‰∫àÁ∑äÊÄ•Ë£úÂÖÖ (Arcade logic)
        if (this.player.ammoCounts['normal'] < 10) {
            this.player.ammoCounts['normal'] += 20;
            this.updateUI();
        }

        this.player.weapon.rotation.z = 0.5;
        new TWEEN.Tween(this.player.weapon.rotation)
            .to({ z: 0 }, 500)
            .easing(TWEEN.Easing.Bounce.Out)
            .start();
    },

    // --- Update Loops ---

    animate: function() {
        requestAnimationFrame(() => this.animate());
        const dt = this.clock.getDelta();
        TWEEN.update();

        if (this.isPlaying) {
            this.updatePlayer(dt);
            this.updateArrows(dt);
            this.updateParticles(dt);
            
            if (this.levelLogic) this.levelLogic.call(this, dt);
            
            if (this.player.combo > 0) {
                this.player.comboTimer -= dt;
                if (this.player.comboTimer <= 0) {
                    this.resetCombo();
                }
            }
        }

        this.renderer.render(this.scene, this.camera);
    },

    updatePlayer: function(dt) {
        // ÁèæÂú®ÊâÄÊúâÊ®°ÂºèÈÉΩÂïüÁî® WASD ÁßªÂãïËàáÈáçÂäõÁâ©ÁêÜ
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);
        right.y = 0; right.normalize();

        const moveDir = new THREE.Vector3();
        if (this.keys['KeyW']) moveDir.add(forward);
        if (this.keys['KeyS']) moveDir.sub(forward);
        if (this.keys['KeyA']) moveDir.sub(right);
        if (this.keys['KeyD']) moveDir.add(right);

        if (moveDir.length() > 0) moveDir.normalize();

        const speed = this.keys['ShiftLeft'] ? 3 : 8;
        this.player.velocity.x = moveDir.x * speed;
        this.player.velocity.z = moveDir.z * speed;
        
        // Gravity
        this.player.velocity.y -= 20 * dt; 
        
        // Apply
        this.camera.position.x += this.player.velocity.x * dt;
        this.camera.position.y += this.player.velocity.y * dt;
        this.camera.position.z += this.player.velocity.z * dt;

        // Floor Collision
        if (this.camera.position.y < 1.7) {
            this.camera.position.y = 1.7;
            this.player.velocity.y = 0;
            this.player.canJump = true;
        }
        
        this.player.weapon.rotation.y = THREE.MathUtils.lerp(this.player.weapon.rotation.y, 0, dt * 5);
        this.player.weapon.rotation.x = THREE.MathUtils.lerp(this.player.weapon.rotation.x, 0, dt * 5);
    },

    updateArrows: function(dt) {
        for (let i = this.arrows.length - 1; i >= 0; i--) {
            const a = this.arrows[i];
            
            a.velocity.y -= a.gravity * dt;
            const step = a.velocity.clone().multiplyScalar(dt);
            
            const dir = step.clone().normalize();
            const dist = step.length();
            this.raycaster.set(a.mesh.position, dir);
            
            const collidables = [...this.targets.map(t => t.mesh), ...this.entities.map(e => e.mesh)];
            const intersects = this.raycaster.intersectObjects(collidables);

            if (intersects.length > 0 && intersects[0].distance <= dist) {
                this.handleHit(intersects[0], a);
                this.scene.remove(a.mesh);
                this.arrows.splice(i, 1);
            } else {
                a.mesh.position.add(step);
                a.mesh.lookAt(a.mesh.position.clone().add(a.velocity));
                a.mesh.rotateX(-Math.PI/2);
                
                a.life -= dt;
                if (a.life <= 0 || a.mesh.position.y < 0) {
                    this.scene.remove(a.mesh);
                    this.arrows.splice(i, 1);
                }
            }
        }
    },

    handleHit: function(hit, arrow) {
        const target = this.targets.find(t => t.mesh === hit.object);
        
        if (target) {
            const localPoint = hit.object.worldToLocal(hit.point.clone());
            const dist = Math.sqrt(localPoint.x*localPoint.x + localPoint.y*localPoint.y);
            
            let points = 10;
            let isCrit = false;

            if (dist < 0.2) { 
                points = 100;
                isCrit = true;
                AudioSynth.playHitBullseye();
            } else if (dist < 0.5) {
                points = 50;
                AudioSynth.playHitWood();
            } else {
                AudioSynth.playHitWood();
            }

            if (arrow.type === 'blast') {
                this.spawnExplosion(hit.point);
                points *= 1.5; 
            }

            this.addScore(points, hit.point, isCrit);
            this.removeTarget(target);
        } else {
            AudioSynth.playHitWood();
            if (arrow.type === 'blast') this.spawnExplosion(hit.point);
            this.resetCombo();
        }
        
        const marker = document.getElementById('hit-marker');
        marker.style.opacity = 1;
        marker.style.transform = 'translate(-50%, -50%) scale(1.2) rotate(45deg)';
        setTimeout(() => {
            marker.style.opacity = 0;
            marker.style.transform = 'translate(-50%, -50%) scale(1) rotate(45deg)';
        }, 100);
    },

    spawnExplosion: function(pos) {
        AudioSynth.playExplosion();
        for(let i=0; i<10; i++) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            p.position.x += (Math.random()-0.5);
            p.position.y += (Math.random()-0.5);
            
            this.scene.add(p);
            this.particles.push({
                mesh: p,
                vel: new THREE.Vector3((Math.random()-0.5)*5, (Math.random())*5, (Math.random()-0.5)*5),
                life: 0.5
            });
        }
        
        const initialY = this.camera.position.y;
        new TWEEN.Tween(this.camera.position)
            .to({ y: initialY - 0.2 }, 50)
            .yoyo(true).repeat(3).start();
    },

    updateParticles: function(dt) {
        for(let i=this.particles.length-1; i>=0; i--) {
            const p = this.particles[i];
            p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
            p.mesh.scale.multiplyScalar(0.9);
            p.life -= dt;
            if(p.life <= 0) {
                this.scene.remove(p.mesh);
                this.particles.splice(i, 1);
            }
        }
    },

    // --- Game Mode Specific Logic ---

    // 1. Target Mode
    targetSpawnTimer: 0,
    updateTargetMode: function(dt) {
        this.targetSpawnTimer -= dt;
        if (this.targetSpawnTimer <= 0) {
            this.spawnTarget();
            this.targetSpawnTimer = Math.max(1.0, 3.0 - (this.player.score / 500)); 
        }
        
        this.targets.forEach(t => {
            if (t.moving) {
                t.mesh.position.x += Math.sin(Date.now() * 0.002) * 0.05;
            }
        });
    },

    spawnTarget: function() {
        const geo = new THREE.CylinderGeometry(1, 1, 0.1, 32);
        geo.rotateX(Math.PI/2); 
        
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#dcb'; ctx.fillRect(0,0,128,128); 
        ctx.beginPath(); ctx.arc(64,64, 50, 0, Math.PI*2); ctx.fillStyle='white'; ctx.fill();
        ctx.beginPath(); ctx.arc(64,64, 30, 0, Math.PI*2); ctx.fillStyle='red'; ctx.fill();
        ctx.beginPath(); ctx.arc(64,64, 15, 0, Math.PI*2); ctx.fillStyle='red'; ctx.fill(); 
        
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshStandardMaterial({ map: tex });
        
        const mesh = new THREE.Mesh(geo, mat);
        
        mesh.position.set(
            (Math.random()-0.5) * 30,
            2 + Math.random() * 5,
            -10 - Math.random() * 20
        );
        mesh.lookAt(this.camera.position); 
        
        this.scene.add(mesh);
        this.targets.push({ mesh: mesh, moving: Math.random() > 0.5 });
    },

    removeTarget: function(target) {
        this.spawnExplosion(target.mesh.position);
        this.scene.remove(target.mesh);
        this.targets = this.targets.filter(t => t !== target);
    },

    // 2. Defense Mode
    defenseWaveTimer: 0,
    updateDefenseMode: function(dt) {
        this.defenseWaveTimer -= dt;
        // ÁßªÈô§‰∫ÜÂº∑Âà∂ÈéñÂÆöÁõ∏Ê©ü‰ΩçÁΩÆÁöÑ‰ª£Á¢ºÔºåÁèæÂú®ÂèØ‰ª•ÁßªÂãï
        
        if (this.defenseWaveTimer <= 0) {
            this.spawnEnemy();
            this.defenseWaveTimer = 2.0;
        }

        this.targets.forEach(e => {
            // Êïµ‰∫∫‰æùÁÑ∂ÊúùÂêë‰∏≠ÂøÉÈªûÁßªÂãï
            const dir = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), e.mesh.position).normalize();
            e.mesh.position.add(dir.multiplyScalar(3 * dt)); 
            e.mesh.lookAt(new THREE.Vector3(0,0,0));
            
            if (e.mesh.position.length() < 2) {
                this.removeTarget(e);
                this.screenFlash(); 
                this.player.combo = 0; 
                this.updateUI();
            }
        });
    },

    spawnEnemy: function() {
        const geo = new THREE.BoxGeometry(1, 2, 1);
        const mat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x330033 });
        const mesh = new THREE.Mesh(geo, mat);
        
        const angle = Math.random() * Math.PI * 2;
        const dist = 30;
        mesh.position.set(Math.cos(angle)*dist, 1, Math.sin(angle)*dist);
        
        this.scene.add(mesh);
        this.targets.push({ mesh: mesh, type: 'enemy' });
    },

    // 3. Patrol Mode
    updatePatrolMode: function(dt) {
        if (this.targets.length < 5 && Math.random() < 0.02) {
            this.spawnTarget();
        }
    },

    // --- UI & Scoring ---

    addScore: function(basePoints, pos, isCrit) {
        this.player.combo++;
        this.player.comboTimer = 3.0;
        
        const multiplier = Math.min(1 + Math.floor(this.player.combo / 5), 4);
        const finalScore = basePoints * multiplier;
        this.player.score += finalScore;
        
        this.createFloatingText(`+${finalScore}`, pos, isCrit);
        
        this.updateUI();
        AudioSynth.playCombo(Math.min(this.player.combo, 10));
    },

    resetCombo: function() {
        this.player.combo = 0;
        this.updateUI();
    },

    createFloatingText: function(text, pos3D, isCrit) {
        const div = document.createElement('div');
        div.className = 'floating-text';
        div.textContent = text;
        div.style.color = isCrit ? '#ff4444' : '#ffffff';
        div.style.fontSize = isCrit ? '30px' : '20px';
        
        const vec = pos3D.clone().project(this.camera);
        const x = (vec.x * .5 + .5) * window.innerWidth;
        const y = (-(vec.y * .5) + .5) * window.innerHeight;
        
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        
        document.getElementById('ui-layer').appendChild(div);
        setTimeout(() => div.remove(), 1000);
    },

    updateUI: function() {
        document.getElementById('score-val').textContent = Math.floor(this.player.score);
        
        // Êõ¥Êñ∞ÂΩàËó•Êï∏Â≠ó
        const type = this.player.ammoTypes[this.player.ammoIndex];
        const count = this.player.ammoCounts[type];
        document.getElementById('ammo-count').textContent = count;
        
        // Â¶ÇÊûúÂΩàËó•ÁÇ∫ 0ÔºåÂ∞áÂ≠óÈ´îËÆäÁ¥Ö
        const ammoEl = document.getElementById('ammo-count').parentElement;
        if (count <= 0) ammoEl.style.color = '#ff4444';
        else ammoEl.style.color = '#fff';

        const comboEl = document.getElementById('combo-display');
        if (this.player.combo > 1) {
            comboEl.textContent = `x${this.player.combo} COMBO`;
            comboEl.classList.add('combo-active');
        } else {
            comboEl.classList.remove('combo-active');
            comboEl.style.opacity = 0;
        }
    },
    
    screenFlash: function() {
        const f = document.getElementById('flash');
        f.style.opacity = 0.8;
        setTimeout(() => f.style.opacity = 0, 100);
    },

    // --- System ---

    startTimer: function(seconds) {
        let t = seconds;
        const el = document.getElementById('timer-val');
        
        if (this.timerInt) clearInterval(this.timerInt);
        
        this.timerInt = setInterval(() => {
            if (!this.isPlaying) return;
            t--;
            const min = Math.floor(t/60).toString().padStart(2, '0');
            const sec = (t%60).toString().padStart(2, '0');
            el.textContent = `${min}:${sec}`;
            
            if (t <= 0) {
                this.endGame();
            }
        }, 1000);
    },

    endGame: function() {
        this.isPlaying = false;
        clearInterval(this.timerInt);
        document.exitPointerLock();
        
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreDisplay = document.getElementById('final-score');
        const passMsg = document.getElementById('multi-pass-msg');
        
        scoreDisplay.textContent = `Final Score: ${Math.floor(this.player.score)}`;
        gameOverScreen.classList.remove('hidden');
        document.getElementById('ui-layer').classList.add('hidden');

        if (this.currentPlayerIndex < this.maxPlayers) {
            document.getElementById('result-title').textContent = "PLAYER " + this.currentPlayerIndex + " FINISHED";
            passMsg.style.display = 'block';
            this.currentPlayerIndex++;
        } else {
            document.getElementById('result-title').textContent = "ALL TRIALS COMPLETE";
            passMsg.style.display = 'none';
            this.currentPlayerIndex = 1;
        }
    },

    returnToMenu: function() {
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
    },

    onWindowResize: function() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
};

window.onload = () => Game.init();

</script>
</body>
</html>
